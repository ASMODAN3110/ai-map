#!/usr/bin/env python3
"""
Test unitaire pour la fonction clean_all_devices de GeophysicalDataCleaner

Ce test v√©rifie le bon fonctionnement de la fonction clean_all_devices
avec de vrais fichiers de donn√©es g√©ophysiques (PD.csv et S.csv).
"""

import sys
import unittest
import pandas as pd
import numpy as np
from pathlib import Path
import shutil
import tempfile

# Ajouter le r√©pertoire parent au path Python
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from src.preprocessor.data_cleaner import GeophysicalDataCleaner


class TestDataCleanerCleanAllDevices(unittest.TestCase):
    """Tests pour la fonction clean_all_devices de GeophysicalDataCleaner"""
    
    def setUp(self):
        """Configuration avant chaque test"""
        # Cr√©er un r√©pertoire temporaire pour les tests
        self.test_dir = Path(tempfile.mkdtemp())
        
        # Cr√©er la structure des dossiers de test
        self.test_raw_dir = self.test_dir / "raw"
        self.test_processed_dir = self.test_dir / "processed"
        self.test_raw_dir.mkdir(parents=True, exist_ok=True)
        self.test_processed_dir.mkdir(parents=True, exist_ok=True)
        
        # Copier les fichiers de test
        fixtures_dir = Path(__file__).parent.parent.parent / "fixtures" / "raw"
        self.pd_test_file = fixtures_dir / "PD.csv"
        self.s_test_file = fixtures_dir / "S.csv"
        
        # Copier les fichiers vers le dossier de test
        if self.pd_test_file.exists():
            shutil.copy2(self.pd_test_file, self.test_raw_dir / "PD.csv")
        if self.s_test_file.exists():
            shutil.copy2(self.s_test_file, self.test_raw_dir / "S.csv")
        
        # Cr√©er une instance du cleaner standard
        self.cleaner = GeophysicalDataCleaner()
    
    def tearDown(self):
        """Nettoyage apr√®s chaque test"""
        # Supprimer le r√©pertoire temporaire
        if self.test_dir.exists():
            shutil.rmtree(self.test_dir)
    
    def test_clean_all_devices_basic_functionality(self):
        """Test de base de la fonction clean_all_devices"""
        print(f"\nüîç Test avec fichiers dans: {self.test_raw_dir}")
        print(f"üìÅ Fichiers disponibles: {list(self.test_raw_dir.glob('*'))}")
        
        # V√©rifier que les fichiers de test existent
        self.assertTrue((self.test_raw_dir / "PD.csv").exists(), "Fichier PD.csv manquant")
        self.assertTrue((self.test_raw_dir / "S.csv").exists(), "Fichier S.csv manquant")
        
        print("‚úÖ Fichiers de test disponibles")
        
        # Test de base : v√©rifier que la fonction existe et est appelable
        self.assertTrue(hasattr(self.cleaner, 'clean_all_devices'))
        self.assertTrue(callable(self.cleaner.clean_all_devices))
        
        print("‚úÖ M√©thode clean_all_devices disponible et appelable")
    
    def test_clean_all_devices_file_validation(self):
        """Test de validation des fichiers de test"""
        # V√©rifier le contenu des fichiers de test
        pd_file = self.test_raw_dir / "PD.csv"
        s_file = self.test_raw_dir / "S.csv"
        
        # Charger et valider PD.csv (Pole-Dipole)
        if pd_file.exists():
            pd_df = pd.read_csv(pd_file, sep=';')
            self.assertGreater(len(pd_df), 0, "Fichier PD.csv vide")
            
            # Colonnes attendues pour PD.csv
            expected_pd_columns = ['x', 'y', 'z', 'Rho(ohm.m)', 'M (mV/V)']
            for col in expected_pd_columns:
                self.assertIn(col, pd_df.columns, f"Colonne {col} manquante dans PD.csv")
            
            print(f"‚úÖ PD.csv: {len(pd_df)} lignes, colonnes: {list(pd_df.columns)}")
        
        # Charger et valider S.csv (Schlumberger)
        if s_file.exists():
            s_df = pd.read_csv(s_file, sep=';')
            self.assertGreater(len(s_df), 0, "Fichier S.csv vide")
            
            # Colonnes attendues pour S.csv
            expected_s_columns = ['LAT', 'LON', 'Rho (Ohm.m)', 'M (mV/V)']
            for col in expected_s_columns:
                self.assertIn(col, s_df.columns, f"Colonne {col} manquante dans S.csv")
            
            print(f"‚úÖ S.csv: {len(s_df)} lignes, colonnes: {list(s_df.columns)}")
    
    def test_clean_all_devices_data_quality(self):
        """Test de la qualit√© des donn√©es de test"""
        # V√©rifier la qualit√© des donn√©es dans PD.csv
        pd_file = self.test_raw_dir / "PD.csv"
        if pd_file.exists():
            pd_df = pd.read_csv(pd_file, sep=';')
            
            # V√©rifier les types de donn√©es
            self.assertTrue(pd_df['x'].dtype in [np.float64, np.int64], "Type x incorrect")
            self.assertTrue(pd_df['y'].dtype in [np.float64, np.int64], "Type y incorrect")
            self.assertTrue(pd_df['z'].dtype in [np.float64, np.int64], "Type z incorrect")
            self.assertTrue(pd_df['Rho(ohm.m)'].dtype in [np.float64, np.int64], "Type Rho incorrect")
            self.assertTrue(pd_df['M (mV/V)'].dtype in [np.float64, np.int64], "Type M incorrect")
            
            # V√©rifier les plages de valeurs
            self.assertTrue(all(pd_df['x'] > 500000), "Coordonn√©es x hors de la zone UTM 30N")
            self.assertTrue(all(pd_df['y'] > 450000), "Coordonn√©es y hors de la zone UTM 30N")
            self.assertTrue(all(pd_df['Rho(ohm.m)'] > 0), "R√©sistivit√© non positive")
            self.assertTrue(all(pd_df['M (mV/V)'] >= 0), "Chargeabilit√© n√©gative")
            
            print("‚úÖ Qualit√© des donn√©es PD.csv valid√©e")
        
        # V√©rifier la qualit√© des donn√©es dans S.csv
        s_file = self.test_raw_dir / "S.csv"
        if s_file.exists():
            s_df = pd.read_csv(s_file, sep=';')
            
            # V√©rifier les types de donn√©es
            self.assertTrue(s_df['LAT'].dtype in [np.float64, np.int64], "Type LAT incorrect")
            self.assertTrue(s_df['LON'].dtype in [np.float64, np.int64], "Type LON incorrect")
            self.assertTrue(s_df['Rho (Ohm.m)'].dtype in [np.float64, np.int64], "Type Rho incorrect")
            self.assertTrue(s_df['M (mV/V)'].dtype in [np.float64, np.int64], "Type M incorrect")
            
            # V√©rifier les plages de valeurs
            self.assertTrue(all(s_df['LAT'].between(4.68, 4.71)), "LAT hors de la plage attendue")
            self.assertTrue(all(s_df['LON'].between(12.34, 12.35)), "LON hors de la plage attendue")
            self.assertTrue(all(s_df['Rho (Ohm.m)'] > 0), "R√©sistivit√© non positive")
            self.assertTrue(all(s_df['M (mV/V)'] >= 0), "Chargeabilit√© n√©gative")
            
            print("‚úÖ Qualit√© des donn√©es S.csv valid√©e")
    
    def test_clean_all_devices_coordinate_consistency(self):
        """Test de la coh√©rence des coordonn√©es entre fichiers"""
        pd_file = self.test_raw_dir / "PD.csv"
        s_file = self.test_raw_dir / "S.csv"
        
        if pd_file.exists() and s_file.exists():
            pd_df = pd.read_csv(pd_file, sep=';')
            s_df = pd.read_csv(s_file, sep=';')
            
            # V√©rifier que les coordonn√©es sont dans des zones g√©ographiques coh√©rentes
            # PD.csv : Coordonn√©es UTM (x, y) - zone 30N (Europe de l'Ouest)
            pd_x_range = (pd_df['x'].min(), pd_df['x'].max())
            pd_y_range = (pd_df['y'].min(), pd_df['y'].max())
            
            # S.csv : Coordonn√©es WGS84 (LAT, LON) - zone √©quatoriale
            s_lat_range = (s_df['LAT'].min(), s_df['LAT'].max())
            s_lon_range = (s_df['LON'].min(), s_df['LON'].max())
            
            # V√©rifier que les coordonn√©es UTM sont dans la zone 30N
            self.assertTrue(all(pd_df['x'] > 500000), "Coordonn√©es x hors de la zone UTM 30N")
            self.assertTrue(all(pd_df['y'] > 450000), "Coordonn√©es y hors de la zone UTM 30N")
            
            # V√©rifier que les coordonn√©es WGS84 sont dans une zone √©quatoriale
            self.assertTrue(all(s_df['LAT'].between(4.68, 4.71)), "LAT hors de la zone √©quatoriale")
            self.assertTrue(all(s_df['LON'].between(12.34, 12.35)), "LON hors de la zone √©quatoriale")
            
            print(f"‚úÖ Coh√©rence des coordonn√©es valid√©e:")
            print(f"   PD (UTM): X {pd_x_range}, Y {pd_y_range}")
            print(f"   S (WGS84): LAT {s_lat_range}, LON {s_lon_range}")
    
    def test_clean_all_devices_method_availability(self):
        """Test de la disponibilit√© des m√©thodes de nettoyage"""
        # V√©rifier que toutes les m√©thodes n√©cessaires sont disponibles
        required_methods = [
            'clean_all_devices',
            'get_cleaning_summary',
            '_clean_device_data'
        ]
        
        for method in required_methods:
            with self.subTest(method=method):
                self.assertTrue(hasattr(self.cleaner, method), f"M√©thode '{method}' manquante")
                method_obj = getattr(self.cleaner, method)
                self.assertTrue(callable(method_obj), f"'{method}' n'est pas appelable")
        
        print(f"‚úÖ Toutes les m√©thodes requises sont disponibles: {required_methods}")
    
    def test_clean_all_devices_attributes(self):
        """Test des attributs de la classe"""
        # V√©rifier que tous les attributs requis existent
        required_attributes = [
            'report',
            'raw_data_dir',
            'processed_data_dir',
            'coord_transformer'
        ]
        
        for attr in required_attributes:
            with self.subTest(attr=attr):
                self.assertTrue(hasattr(self.cleaner, attr), f"Attribut '{attr}' manquant")
        
        print(f"‚úÖ Tous les attributs requis sont pr√©sents: {required_attributes}")
        
        # V√©rifier les types des attributs
        self.assertIsInstance(self.cleaner.report, dict, "report doit √™tre un dictionnaire")
        self.assertIsInstance(self.cleaner.raw_data_dir, Path, "raw_data_dir doit √™tre un Path")
        self.assertIsInstance(self.cleaner.processed_data_dir, Path, "processed_data_dir doit √™tre un Path")
        
        print("‚úÖ Types des attributs valid√©s")
    
    def test_clean_all_devices_data_structure(self):
        """Test de la structure des donn√©es g√©ophysiques"""
        pd_file = self.test_raw_dir / "PD.csv"
        s_file = self.test_raw_dir / "S.csv"
        
        # V√©rifier PD.csv (Pole-Dipole)
        if pd_file.exists():
            pd_df = pd.read_csv(pd_file, sep=';')
            
            # V√©rifier que les donn√©es contiennent des mesures g√©ophysiques
            self.assertTrue(len(pd_df) > 0, "PD.csv ne contient aucune mesure")
            self.assertTrue(all(pd_df['Rho(ohm.m)'] > 0), "R√©sistivit√© non positive dans PD.csv")
            self.assertTrue(all(pd_df['M (mV/V)'] >= 0), "Chargeabilit√© n√©gative dans PD.csv")
            
            print(f"‚úÖ Structure PD.csv valid√©e: {len(pd_df)} mesures g√©ophysiques")
        
        # V√©rifier S.csv (Schlumberger)
        if s_file.exists():
            s_df = pd.read_csv(s_file, sep=';')
            
            # V√©rifier que les donn√©es contiennent des mesures g√©ophysiques
            self.assertTrue(len(s_df) > 0, "S.csv ne contient aucune mesure")
            self.assertTrue(all(s_df['Rho (Ohm.m)'] > 0), "R√©sistivit√© non positive dans S.csv")
            self.assertTrue(all(s_df['M (mV/V)'] >= 0), "Chargeabilit√© n√©gative dans S.csv")
            
            print(f"‚úÖ Structure S.csv valid√©e: {len(s_df)} mesures g√©ophysiques")


if __name__ == "__main__":
    # Configuration des tests
    unittest.main(
        verbosity=2,
        testLoader=unittest.TestLoader(),
        testRunner=unittest.TextTestRunner(stream=sys.stdout)
    )
