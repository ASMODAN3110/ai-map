"""
Exemple Complet : Mod√®le Hybride Images + Donn√©es G√©ophysiques
==============================================================

Ce script d√©montre l'utilisation compl√®te du syst√®me hybride qui combine :
- Images g√©ophysiques (r√©sistivit√©, chargeabilit√©, etc.)
- Donn√©es g√©ophysiques tabulaires (mesures, coordonn√©es, etc.)

Fonctionnalit√©s d√©montr√©es :
1. Chargement et traitement d'images
2. Pr√©paration des donn√©es hybrides
3. Cr√©ation et entra√Ænement du mod√®le hybride
4. √âvaluation et pr√©dictions
5. Sauvegarde et chargement du mod√®le
"""

import os
import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
import tempfile
import shutil

# Ajouter le r√©pertoire src au path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'src'))

# Import des modules du projet
from data.image_processor import GeophysicalImageProcessor, ImageAugmenter
from model.geophysical_hybrid_net import GeophysicalHybridNet, create_hybrid_model
from model.geophysical_image_trainer import GeophysicalImageTrainer, create_hybrid_trainer
from preprocessor.data_augmenter import GeophysicalDataAugmenter


def create_sample_images(output_dir: str, num_images: int = 20) -> tuple:
    """
    Cr√©er des images d'exemple pour la d√©monstration.
    
    Args:
        output_dir (str): Dossier de sortie
        num_images (int): Nombre d'images √† cr√©er
        
    Returns:
        tuple: (chemins des images, labels correspondants)
    """
    os.makedirs(output_dir, exist_ok=True)
    
    image_paths = []
    labels = []
    
    print(f"üé® Cr√©ation de {num_images} images d'exemple...")
    
    for i in range(num_images):
        # Cr√©er des images avec des patterns diff√©rents selon la classe
        if i < num_images // 2:
            # Classe 0: Images avec des lignes horizontales (stratification)
            img = Image.new('RGB', (128, 128), color='darkblue')
            pixels = img.load()
            
            # Ajouter des lignes horizontales
            for y in range(0, 128, 20):
                for x in range(128):
                    pixels[x, y] = (255, 255, 255)  # Lignes blanches
            
            label = 0
            filename = f"stratification_{i:02d}.png"
        else:
            # Classe 1: Images avec des lignes verticales (fractures)
            img = Image.new('RGB', (128, 128), color='darkred')
            pixels = img.load()
            
            # Ajouter des lignes verticales
            for x in range(0, 128, 20):
                for y in range(128):
                    pixels[x, y] = (255, 255, 255)  # Lignes blanches
            
            label = 1
            filename = f"fracture_{i:02d}.png"
        
        # Sauvegarder l'image
        filepath = os.path.join(output_dir, filename)
        img.save(filepath)
        
        image_paths.append(filepath)
        labels.append(label)
    
    print(f"‚úÖ {len(image_paths)} images cr√©√©es dans {output_dir}")
    return image_paths, labels


def create_sample_geophysical_data(num_samples: int = 20) -> tuple:
    """
    Cr√©er des donn√©es g√©ophysiques d'exemple.
    
    Args:
        num_samples (int): Nombre d'√©chantillons
        
    Returns:
        tuple: (donn√©es g√©ophysiques, labels)
    """
    print(f"üìä Cr√©ation de {num_samples} √©chantillons de donn√©es g√©ophysiques...")
    
    # Donn√©es simul√©es
    np.random.seed(42)
    
    geo_data = []
    labels = []
    
    for i in range(num_samples):
        if i < num_samples // 2:
            # Classe 0: Donn√©es de stratification
            resistivity = np.random.normal(150, 30)  # Ohm.m
            chargeability = np.random.normal(25, 5)   # mV/V
            sp_potential = np.random.normal(12, 3)   # mV
            coordinates = np.random.uniform(100, 200, 2)  # X, Y
            
            label = 0
        else:
            # Classe 1: Donn√©es de fracturation
            resistivity = np.random.normal(80, 20)   # Ohm.m
            chargeability = np.random.normal(40, 8)   # mV/V
            sp_potential = np.random.normal(25, 6)   # mV
            coordinates = np.random.uniform(200, 300, 2)  # X, Y
            
            label = 1
        
        # Cr√©er le vecteur de features
        features = [resistivity, chargeability, sp_potential, coordinates[0], coordinates[1]]
        geo_data.append(features)
        labels.append(label)
    
    print(f"‚úÖ {len(geo_data)} √©chantillons de donn√©es g√©ophysiques cr√©√©s")
    return geo_data, labels


def demonstrate_image_processing(image_paths: list, output_dir: str):
    """
    D√©montrer le traitement d'images.
    
    Args:
        image_paths (list): Chemins des images
        output_dir (str): Dossier de sortie
    """
    print("\nüñºÔ∏è  D√©monstration du traitement d'images...")
    
    # Cr√©er le processeur d'images
    processor = GeophysicalImageProcessor(target_size=(64, 64), channels=3)
    
    # Traiter quelques images
    sample_images = image_paths[:3]
    
    for i, image_path in enumerate(sample_images):
        print(f"  Traitement de l'image {i+1}/{len(sample_images)}...")
        
        # Traiter l'image
        tensor = processor.process_image(image_path)
        print(f"    Forme du tenseur: {tensor.shape}")
        
        # Extraire des features
        features = processor.extract_geophysical_features(image_path)
        print(f"    Intensit√© moyenne: {features['mean_intensity']:.2f}")
        print(f"    Magnitude du gradient: {features['gradient_magnitude']:.2f}")
        
        # Sauvegarder l'image pr√©trait√©e
        processed_filename = f"processed_{os.path.basename(image_path)}"
        processed_path = os.path.join(output_dir, processed_filename)
        processor.save_processed_image(image_path, processed_path)
        print(f"    Image pr√©trait√©e sauvegard√©e: {processed_filename}")
    
    print("‚úÖ Traitement d'images termin√©")


def demonstrate_image_augmentation(image_paths: list, output_dir: str):
    """
    D√©montrer l'augmentation d'images.
    
    Args:
        image_paths (list): Chemins des images
        output_dir (str): Dossier de sortie
    """
    print("\nüîÑ D√©monstration de l'augmentation d'images...")
    
    # Cr√©er l'augmenteur
    augmenter = ImageAugmenter(random_seed=42)
    
    # S√©lectionner une image pour la d√©monstration
    demo_image_path = image_paths[0]
    demo_image = Image.open(demo_image_path)
    
    # Techniques d'augmentation
    augmentations = ["rotation", "flip_horizontal", "brightness", "contrast"]
    
    print(f"  Augmentation de l'image: {os.path.basename(demo_image_path)}")
    print(f"  Techniques: {', '.join(augmentations)}")
    
    # G√©n√©rer des augmentations
    augmented_images = augmenter.augment_image(demo_image, augmentations, num_augmentations=2)
    
    print(f"  {len(augmented_images)} versions cr√©√©es (original + augmentations)")
    
    # Sauvegarder les images augment√©es
    for i, aug_image in enumerate(augmented_images):
        filename = f"augmented_{i:02d}_{os.path.basename(demo_image_path)}"
        filepath = os.path.join(output_dir, filename)
        aug_image.save(filepath)
    
    # R√©sum√© des augmentations
    summary = augmenter.get_augmentation_summary()
    print(f"  Total d'augmentations effectu√©es: {summary['total_augmentations']}")
    print(f"  Types d'augmentation: {', '.join(summary['augmentation_types'])}")
    
    print("‚úÖ Augmentation d'images termin√©e")


def demonstrate_hybrid_model_creation():
    """
    D√©montrer la cr√©ation du mod√®le hybride.
    
    Returns:
        GeophysicalHybridNet: Mod√®le cr√©√©
    """
    print("\nüß† D√©monstration de la cr√©ation du mod√®le hybride...")
    
    # Cr√©er le mod√®le
    model = create_hybrid_model(
        num_classes=2,
        image_model="resnet18",
        geo_input_dim=5,
        fusion_method="concatenation"
    )
    
    print(f"  Mod√®le cr√©√©: {model.__class__.__name__}")
    print(f"  Classes de sortie: {model.num_classes}")
    print(f"  Mod√®le d'images: {model.image_model}")
    print(f"  M√©thode de fusion: {model.fusion_method}")
    
    # Compter les param√®tres
    param_counts = model.count_parameters()
    print(f"  Param√®tres totaux: {param_counts['total_parameters']:,}")
    print(f"  Param√®tres entra√Ænables: {param_counts['trainable_parameters']:,}")
    
    # Test du forward pass
    print("  Test du forward pass...")
    batch_size = 2
    test_images = torch.randn(batch_size, 3, 64, 64)
    test_geo_data = torch.randn(batch_size, 5)
    
    with torch.no_grad():
        output = model(test_images, test_geo_data)
        print(f"    Entr√©e images: {test_images.shape}")
        print(f"    Entr√©e donn√©es g√©o: {test_geo_data.shape}")
        print(f"    Sortie: {output.shape}")
    
    print("‚úÖ Mod√®le hybride cr√©√© avec succ√®s")
    return model


def demonstrate_hybrid_training(image_paths: list, geo_data: list, labels: list, 
                              output_dir: str, model: GeophysicalHybridNet):
    """
    D√©montrer l'entra√Ænement du mod√®le hybride.
    
    Args:
        image_paths (list): Chemins des images
        geo_data (list): Donn√©es g√©ophysiques
        labels (list): Labels
        output_dir (str): Dossier de sortie
        model (GeophysicalHybridNet): Mod√®le √† entra√Æner
        
    Returns:
        dict: Historique d'entra√Ænement
    """
    print("\nüöÄ D√©monstration de l'entra√Ænement du mod√®le hybride...")
    
    # Cr√©er le trainer
    augmenter = GeophysicalDataAugmenter()
    trainer = create_hybrid_trainer(augmenter)
    
    print(f"  Trainer cr√©√©: {trainer.__class__.__name__}")
    print(f"  Device: {trainer.device}")
    
    # Pr√©parer les donn√©es hybrides
    print("  Pr√©paration des donn√©es hybrides...")
    train_loader, val_loader = trainer.prepare_hybrid_data(
        image_paths, geo_data, labels,
        test_size=0.3,
        augmentations=["rotation", "flip_horizontal"],
        num_augmentations=1
    )
    
    print(f"  Donn√©es d'entra√Ænement: {len(train_loader.dataset)} √©chantillons")
    print(f"  Donn√©es de validation: {len(val_loader.dataset)} √©chantillons")
    
    # Entra√Æner le mod√®le (version courte pour la d√©monstration)
    print("  D√©but de l'entra√Ænement...")
    history = trainer.train_hybrid_model(
        model, train_loader, val_loader,
        num_epochs=5,  # Court pour la d√©monstration
        learning_rate=0.001,
        patience=3
    )
    
    print("‚úÖ Entra√Ænement termin√©")
    return history


def demonstrate_model_evaluation(trainer: GeophysicalImageTrainer, 
                               image_paths: list, geo_data: list, labels: list):
    """
    D√©montrer l'√©valuation du mod√®le.
    
    Args:
        trainer (GeophysicalImageTrainer): Trainer
        image_paths (list): Chemins des images
        geo_data (list): Donn√©es g√©ophysiques
        labels (list): Labels
    """
    print("\nüìä D√©monstration de l'√©valuation du mod√®le...")
    
    # Pr√©parer les donn√©es de test
    from sklearn.model_selection import train_test_split
    
    (X_img_train, X_img_test, 
     X_geo_train, X_geo_test, 
     y_train, y_test) = train_test_split(
        image_paths, geo_data, labels,
        test_size=0.3, random_state=42, stratify=labels
    )
    
    # Cr√©er le loader de test
    test_loader = trainer.prepare_hybrid_data(
        X_img_test, X_geo_test, y_test,
        test_size=0.0  # Pas de split train/val pour le test
    )[1]  # Prendre le deuxi√®me loader (validation)
    
    print(f"  Donn√©es de test: {len(test_loader.dataset)} √©chantillons")
    
    # √âvaluer le mod√®le
    metrics = trainer.evaluate_hybrid_model(trainer.model, test_loader)
    
    print("  R√©sultats de l'√©valuation:")
    print(f"    Test Loss: {metrics['test_loss']:.4f}")
    print(f"    Test Accuracy: {metrics['test_accuracy']:.2f}%")
    print(f"    √âchantillons corrects: {metrics['correct_predictions']}/{metrics['total_samples']}")
    
    print("‚úÖ √âvaluation termin√©e")


def demonstrate_model_saving_and_loading(model: GeophysicalHybridNet, output_dir: str):
    """
    D√©montrer la sauvegarde et le chargement du mod√®le.
    
    Args:
        model (GeophysicalHybridNet): Mod√®le √† sauvegarder
        output_dir (str): Dossier de sortie
    """
    print("\nüíæ D√©monstration de la sauvegarde et du chargement du mod√®le...")
    
    # Chemin de sauvegarde
    model_path = os.path.join(output_dir, "hybrid_model_example.pth")
    
    # Sauvegarder le mod√®le
    print(f"  Sauvegarde du mod√®le dans: {model_path}")
    torch.save({
        'model_state_dict': model.state_dict(),
        'model_config': {
            'num_classes': model.num_classes,
            'image_model': model.image_model,
            'fusion_method': model.fusion_method
        },
        'timestamp': '2024-01-01'
    }, model_path)
    
    # Charger le mod√®le
    print("  Chargement du mod√®le...")
    checkpoint = torch.load(model_path)
    
    # Cr√©er un nouveau mod√®le avec la m√™me configuration
    loaded_model = create_hybrid_model(
        num_classes=checkpoint['model_config']['num_classes'],
        image_model=checkpoint['model_config']['image_model'],
        fusion_method=checkpoint['model_config']['fusion_method']
    )
    
    # Charger les poids
    loaded_model.load_state_dict(checkpoint['model_state_dict'])
    
    print("  V√©rification du mod√®le charg√©...")
    
    # Test du mod√®le charg√©
    batch_size = 2
    test_images = torch.randn(batch_size, 3, 64, 64)
    test_geo_data = torch.randn(batch_size, 5)
    
    with torch.no_grad():
        original_output = model(test_images, test_geo_data)
        loaded_output = loaded_model(test_images, test_geo_data)
        
        # V√©rifier que les sorties sont identiques
        output_diff = torch.abs(original_output - loaded_output).max()
        print(f"    Diff√©rence maximale entre mod√®les: {output_diff:.6f}")
        
        if output_diff < 1e-6:
            print("    ‚úÖ Mod√®le charg√© avec succ√®s (sorties identiques)")
        else:
            print("    ‚ö†Ô∏è  Diff√©rences d√©tect√©es dans le mod√®le charg√©")
    
    print("‚úÖ Sauvegarde et chargement termin√©s")


def create_demo_report(output_dir: str, image_paths: list, geo_data: list, labels: list):
    """
    Cr√©er un rapport de d√©monstration.
    
    Args:
        output_dir (str): Dossier de sortie
        image_paths (list): Chemins des images
        geo_data (list): Donn√©es g√©ophysiques
        labels (list): Labels
    """
    print("\nüìã Cr√©ation du rapport de d√©monstration...")
    
    report_path = os.path.join(output_dir, "demo_report.txt")
    
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write("RAPPORT DE D√âMONSTRATION - MOD√àLE HYBRIDE IMAGES + DONN√âES G√âOPHYSIQUES\n")
        f.write("=" * 80 + "\n\n")
        
        f.write("1. DONN√âES UTILIS√âES\n")
        f.write("-" * 30 + "\n")
        f.write(f"Nombre total d'images: {len(image_paths)}\n")
        f.write(f"Nombre total d'√©chantillons g√©ophysiques: {len(geo_data)}\n")
        f.write(f"Nombre de classes: {len(set(labels))}\n")
        f.write(f"Distribution des classes: {dict(zip(*np.unique(labels, return_counts=True)))}\n\n")
        
        f.write("2. IMAGES CR√â√âES\n")
        f.write("-" * 20 + "\n")
        for i, path in enumerate(image_paths):
            filename = os.path.basename(path)
            label = labels[i]
            f.write(f"  {i+1:2d}. {filename} -> Classe {label}\n")
        f.write("\n")
        
        f.write("3. DONN√âES G√âOPHYSIQUES\n")
        f.write("-" * 30 + "\n")
        f.write("Features: [R√©sistivit√©, Chargeabilit√©, Potentiel SP, Coordonn√©e X, Coordonn√©e Y]\n")
        f.write("Unit√©s: [Ohm.m, mV/V, mV, m, m]\n\n")
        
        f.write("4. FONCTIONNALIT√âS D√âMONTR√âES\n")
        f.write("-" * 40 + "\n")
        f.write("‚úÖ Traitement d'images g√©ophysiques\n")
        f.write("‚úÖ Augmentation d'images\n")
        f.write("‚úÖ Cr√©ation de mod√®le hybride\n")
        f.write("‚úÖ Entra√Ænement du mod√®le\n")
        f.write("‚úÖ √âvaluation et m√©triques\n")
        f.write("‚úÖ Sauvegarde et chargement\n")
        f.write("‚úÖ Rapport de d√©monstration\n\n")
        
        f.write("5. FICHIERS G√âN√âR√âS\n")
        f.write("-" * 25 + "\n")
        for filename in os.listdir(output_dir):
            filepath = os.path.join(output_dir, filename)
            if os.path.isfile(filepath):
                size = os.path.getsize(filepath)
                f.write(f"  {filename} ({size:,} bytes)\n")
    
    print(f"  Rapport cr√©√©: {report_path}")
    print("‚úÖ Rapport de d√©monstration termin√©")


def main():
    """Fonction principale de d√©monstration."""
    print("üöÄ D√âMONSTRATION COMPL√àTE - MOD√àLE HYBRIDE IMAGES + DONN√âES G√âOPHYSIQUES")
    print("=" * 80)
    
    # Cr√©er le dossier de sortie
    output_dir = "artifacts/demo_hybrid"
    os.makedirs(output_dir, exist_ok=True)
    
    try:
        # 1. Cr√©er les donn√©es d'exemple
        print("\nüìÅ √âTAPE 1: Cr√©ation des donn√©es d'exemple")
        image_paths, image_labels = create_sample_images(output_dir, num_images=20)
        geo_data, geo_labels = create_sample_geophysical_data(num_samples=20)
        
        # V√©rifier que les labels correspondent
        assert image_labels == geo_labels, "Les labels des images et donn√©es g√©o doivent correspondre"
        labels = image_labels
        
        # 2. D√©montrer le traitement d'images
        print("\nüìÅ √âTAPE 2: Traitement d'images")
        demonstrate_image_processing(image_paths, output_dir)
        
        # 3. D√©montrer l'augmentation d'images
        print("\nüìÅ √âTAPE 3: Augmentation d'images")
        demonstrate_image_augmentation(image_paths, output_dir)
        
        # 4. Cr√©er le mod√®le hybride
        print("\nüìÅ √âTAPE 4: Cr√©ation du mod√®le hybride")
        model = demonstrate_hybrid_model_creation()
        
        # 5. Entra√Æner le mod√®le
        print("\nüìÅ √âTAPE 5: Entra√Ænement du mod√®le")
        history = demonstrate_hybrid_training(image_paths, geo_data, labels, output_dir, model)
        
        # 6. √âvaluer le mod√®le
        print("\nüìÅ √âTAPE 6: √âvaluation du mod√®le")
        augmenter = GeophysicalDataAugmenter()
        trainer = create_hybrid_trainer(augmenter)
        trainer.model = model  # Assigner le mod√®le entra√Æn√©
        demonstrate_model_evaluation(trainer, image_paths, geo_data, labels)
        
        # 7. Sauvegarder et charger le mod√®le
        print("\nüìÅ √âTAPE 7: Sauvegarde et chargement")
        demonstrate_model_saving_and_loading(model, output_dir)
        
        # 8. Cr√©er le rapport
        print("\nüìÅ √âTAPE 8: Rapport de d√©monstration")
        create_demo_report(output_dir, image_paths, geo_data, labels)
        
        print("\nüéâ D√âMONSTRATION TERMIN√âE AVEC SUCC√àS!")
        print(f"üìÅ Tous les fichiers ont √©t√© cr√©√©s dans: {output_dir}")
        print("\nüìã R√©sum√© des fonctionnalit√©s test√©es:")
        print("  ‚úÖ Traitement d'images g√©ophysiques")
        print("  ‚úÖ Augmentation d'images")
        print("  ‚úÖ Mod√®le hybride CNN + donn√©es g√©ophysiques")
        print("  ‚úÖ Entra√Ænement complet")
        print("  ‚úÖ √âvaluation et m√©triques")
        print("  ‚úÖ Sauvegarde/chargement")
        print("  ‚úÖ Pipeline end-to-end")
        
    except Exception as e:
        print(f"\n‚ùå Erreur lors de la d√©monstration: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    return True


if __name__ == "__main__":
    # V√©rifier que PyTorch est disponible
    try:
        import torch
        print(f"‚úÖ PyTorch {torch.__version__} d√©tect√©")
    except ImportError:
        print("‚ùå PyTorch n'est pas install√©. Installez-le avec: pip install torch torchvision")
        sys.exit(1)
    
    # Lancer la d√©monstration
    success = main()
    
    if success:
        print("\nüéØ Prochaines √©tapes sugg√©r√©es:")
        print("  1. Tester avec vos propres donn√©es g√©ophysiques")
        print("  2. Ajuster les hyperparam√®tres du mod√®le")
        print("  3. Exp√©rimenter avec diff√©rentes m√©thodes de fusion")
        print("  4. Int√©grer dans votre pipeline de production")
        print("  5. Ajouter des m√©triques d'√©valuation personnalis√©es")
    else:
        print("\nüîß Pour r√©soudre les probl√®mes:")
        print("  1. V√©rifiez que toutes les d√©pendances sont install√©es")
        print("  2. Assurez-vous que les chemins sont corrects")
        print("  3. V√©rifiez les permissions d'√©criture")
        print("  4. Consultez les logs d'erreur d√©taill√©s")
