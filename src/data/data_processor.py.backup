import numpy as np
import pandas as pd
from pathlib import Path
from typing import Tuple, Dict, List

from config import CONFIG
from src.utils.logger import logger


class GeophysicalDataProcessor:
    """
    Processeur pour les données géophysiques, inspiré du DataProcessor d'EMUT.
    """
    
    def __init__(self):
        self.scalers = {}
        self.spatial_grids = {}
        self.device_data = {}
        
    def load_and_validate(self) -> Dict[str, pd.DataFrame]:
        """Charger et valider les données nettoyées de tous les dispositifs."""
        logger.info("Chargement et validation des données géophysiques...")
        
        processed_dir = Path(CONFIG.paths.processed_data_dir)
        
        # Chercher tous les fichiers nettoyés
        clean_files = list(processed_dir.glob("*_cleaned.csv"))
        
        if not clean_files:
            logger.warning("Aucun fichier nettoyé trouvé")
            return {}
        
        for clean_file in clean_files:
            device_name = clean_file.stem.replace("_cleaned", "")
            
            try:
                df = pd.read_csv(clean_file)
                logger.info(f"Chargé {len(df)} enregistrements pour {device_name}")
                self.device_data[device_name] = df
            except Exception as e:
                logger.warning(f"Erreur lors du chargement de {clean_file}: {e}")
                
        return self.device_data
    
    def create_spatial_grids(self) -> Dict[str, np.ndarray]:
        """Créer des grilles spatiales pour chaque dispositif."""
        logger.info("Création des grilles spatiales pour les dispositifs...")
        
        for device_name, df in self.device_data.items():
            grid_2d = self._create_2d_grid(df, device_name)
            self.spatial_grids[device_name] = grid_2d
            
        return self.spatial_grids
    
    def _create_2d_grid(self, df: pd.DataFrame, device_name: str) -> np.ndarray:
        """Créer une grille 2D pour les données du dispositif."""
        grid_shape = CONFIG.processing.grid_2d
        
        # Obtenir les limites spatiales
        x_min, x_max = df['x'].min(), df['x'].max()
        y_min, y_max = df['y'].min(), df['y'].max()
        
        # Créer les coordonnées de la grille
        x_grid = np.linspace(x_min, x_max, grid_shape[0])
        y_grid = np.linspace(y_min, y_max, grid_shape[1])
        
        # Initialiser la grille avec des zéros
        grid = np.zeros((grid_shape[0], grid_shape[1], 4))
        
        # Interpolation simple - remplir avec le plus proche voisin
        for i, x in enumerate(x_grid):
            for j, y in enumerate(y_grid):
                # Trouver le point de données le plus proche
                distances = np.sqrt((df['x'] - x)**2 + (df['y'] - y)**2)
                nearest_idx = np.argmin(distances)
                
                # Remplir la grille avec les mesures
                # Mapper les colonnes réelles aux indices de la grille
                if 'Rho(ohm.m)' in df.columns:
                    grid[i, j, 0] = df.iloc[nearest_idx]['Rho(ohm.m)']
                elif 'resistivity' in df.columns:
                    grid[i, j, 0] = df.iloc[nearest_idx]['resistivity']
                    
                if 'M (mV/V)' in df.columns:
                    grid[i, j, 1] = df.iloc[nearest_idx]['M (mV/V)']
                elif 'chargeability' in df.columns:
                    grid[i, j, 1] = df.iloc[nearest_idx]['chargeability']
                    
                grid[i, j, 2] = df.iloc[nearest_idx]['x']
                grid[i, j, 3] = df.iloc[nearest_idx]['y']
        
        logger.debug(f"Grille {grid_shape} créée pour {device_name}")
        return grid
    
    def create_multi_device_tensor(self) -> np.ndarray:
        """Créer un tenseur multi-dispositifs pour l'entrée CNN."""
        logger.info("Création du tenseur multi-dispositifs...")
        
        # Créer d'abord les grilles spatiales
        spatial_grids = self.create_spatial_grids()
        
        # Empiler toutes les grilles des dispositifs
        device_tensors = []
        for device_name in CONFIG.geophysical_data.devices.keys():
            if device_name in spatial_grids:
                device_tensors.append(spatial_grids[device_name])
        
        if not device_tensors:
            # Créer un tenseur factice si aucune donnée
            height, width = CONFIG.processing.grid_2d
            channels = 4
            dummy_tensor = np.zeros((1, height, width, channels))
            logger.warning("Aucune donnée de dispositif trouvée, tenseur factice créé")
            return dummy_tensor
        
        # Empiler le long de la dimension batch
        multi_device_tensor = np.stack(device_tensors, axis=0)
        
        logger.info(f"Tenseur multi-dispositifs créé: {multi_device_tensor.shape}")
        return multi_device_tensor
    
    def create_3d_volume(self) -> np.ndarray:
        """Créer un volume 3D pour l'entrée VoxNet."""
        logger.info("Création du volume 3D pour VoxNet...")
        
        grid_3d = CONFIG.processing.grid_3d
        channels = 4
        
        # Créer un volume 3D
        volume = np.zeros((grid_3d[0], grid_3d[1], grid_3d[2], channels))
        
        # Obtenir le tenseur 2D et l'étendre en 3D
        multi_device_tensor = self.create_multi_device_tensor()
        
        if multi_device_tensor.shape[0] > 0:
            # Utiliser le premier dispositif comme base et l'étendre en 3D
            base_2d = multi_device_tensor[0]  # (height, width, channels)
            
            # Dupliquer à travers la profondeur
            for d in range(grid_3d[0]):
                volume[d] = base_2d
        
        logger.info(f"Volume 3D créé: {volume.shape}")
        return volume
    
    def split_data(self, tensor: np.ndarray, labels: np.ndarray = None) -> Tuple:
        """Diviser les données en ensembles d'entraînement et de test."""
        # Division simple pour l'instant
        split_idx = int(len(tensor) * 0.8)
        x_train = tensor[:split_idx]
        x_test = tensor[split_idx:]
        
        logger.info(f"Taille de l'ensemble d'entraînement: {len(x_train)}")
        logger.info(f"Taille de l'ensemble de test: {len(x_test)}")
        
        return x_train, x_test
    
    def get_data_summary(self) -> Dict:
        """Obtenir un résumé des données traitées."""
        summary = {
            'devices_processed': len(self.device_data),
            'spatial_grids_created': len(self.spatial_grids),
            'scalers_created': len(self.scalers),
            'device_details': {}
        }
        
        for device_name, df in self.device_data.items():
            summary['device_details'][device_name] = {
                'record_count': len(df),
                'spatial_coverage': {
                    'x_range': df['x'].max() - df['x'].min(),
                    'y_range': df['y'].max() - df['y'].min()
                }
            }
        
        return summary
